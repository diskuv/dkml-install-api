<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dkml_install_api (dkml-install.Dkml_install_api)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">dkml-install</a> &#x00BB; Dkml_install_api</nav><header class="odoc-preamble"><h1>Module <code><span>Dkml_install_api</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#component-configuration">Component Configuration</a><ul><li><a href="#configuration">Configuration</a></li><li><a href="#process-execution">Process execution</a></li><li><a href="#uninstallation">Uninstallation</a></li><li><a href="#logging">Logging</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="component-configuration"><a href="#component-configuration" class="anchor"></a>Component Configuration</h3><p>You are responsible for creating a module of type <a href="module-type-Component_config/index.html"><code>Component_config</code></a> to describe your component. A do-nothing implementation for most of the module is available as <a href="Default_component_config/index.html"><code>Default_component_config</code></a>.</p><p><code>Dkml_install_api</code> will use the <a href="module-type-Component_config/index.html"><code>Component_config</code></a> to create four (4) command line applications.</p><p>Each of the command line applications are &quot;subcommands&quot; in the language of the OCaml <code>Cmdliner</code> package. You will not need to understand Cmdliner to define your own component, although you may visit the <a href="https://erratique.ch/software/cmdliner">Cmdliner documentation</a> if you want more information.</p><p>The four (4) command line applications have limited access to the OCaml runtime. The expectation is that all installation logic is embedded in bytecode executables which have the complete set of package dependencies you need to run your logic. Through <a href="module-type-Component_config/index.html"><code>Component_config</code></a> <code>Dkml_install_api</code> will have given you a <code>~ctx_t</code> Cmdliner term that, when evaluated, leads to the context record <a href="Context/index.html#type-t"><code>Context.t</code></a>. The context record has the information needed to run your bytecode executables.</p><p>On Windows it is <a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works">recommended security practice</a> to separate functionality that requires administrative privileges from functionality that does not require non-administrative privileges. <code>Dkml_install_api</code> follows the same recommendations:</p><ul><li>There will be a <em>single</em> executable <code>&quot;&lt;package&gt;-admin-runner.exe&quot;</code> that is responsible for the following functionality for <em>all</em> components:</li></ul><ol><li>Administrator installation defined by <a href="module-type-Component_config/index.html#val-install_admin_subcommand"><code>Component_config.install_admin_subcommand</code></a></li><li>Administrator uninstallation defined by <a href="module-type-Component_config/index.html#val-uninstall_admin_subcommand"><code>Component_config.uninstall_admin_subcommand</code></a></li></ol><ul><li>There will be a <em>single</em> executable <code>&quot;&lt;package&gt;-user-runner.exe&quot;</code> that is responsible for the following functionality for <em>all</em> components:</li></ul><ol><li>User installation defined by <a href="module-type-Component_config/index.html#val-install_user_subcommand"><code>Component_config.install_user_subcommand</code></a></li><li>User uninstallation defined by <a href="module-type-Component_config/index.html#val-uninstall_user_subcommand"><code>Component_config.uninstall_user_subcommand</code></a></li></ol><div class="odoc-spec"><div class="spec module anchored" id="module-Context"><a href="#module-Context" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Context/index.html">Context</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Context</code> is a module providing a record type for the context.</p></div></div><h5 id="configuration"><a href="#configuration" class="anchor"></a>Configuration</h5><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Component_config_defaultable"><a href="#module-type-Component_config_defaultable" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Component_config_defaultable/index.html">Component_config_defaultable</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Component configuration values that can be supplied with defaults.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Component_config"><a href="#module-type-Component_config" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Component_config/index.html">Component_config</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Each component must define a configuration module</p></div></div><p>You <em>should</em> <code>include Default_component_config</code> in any of your components so that your component can be future-proof against changes in the <a href="module-type-Component_config/index.html"><code>Component_config</code></a> signature.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Default_component_config"><a href="#module-Default_component_config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Default_component_config/index.html">Default_component_config</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Default values for a subset of the module type <a href="module-type-Component_config/index.html"><code>Component_config</code></a>.</p></div></div><h5 id="process-execution"><a href="#process-execution" class="anchor"></a>Process execution</h5><div class="odoc-spec"><div class="spec value anchored" id="val-log_spawn_onerror_exit"><a href="#val-log_spawn_onerror_exit" class="anchor"></a><code><span><span class="keyword">val</span> log_spawn_onerror_exit : 
  <span>id:string <span class="arrow">&#45;&gt;</span></span>
  <span>?conformant_subprocess_exitcodes:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bos</span>.Cmd.t <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>log_spawn_onerror_exit ~id ?conformant_subprocess_exitcodes cmd</code> logs the command <code>cmd</code> and runs it synchronously, and prints an error on the fatal logger <code>fl ~id</code> and then exits with a non-zero exit code if the command exits with a non-zero error code.</p><p>The environment variable <code>&quot;OCAMLRUNPARAM&quot;</code> will be set to <code>&quot;b&quot;</code> so that any OCaml bytecode launched by <code>log_spawn_onerror_exit</code> will have backtraces. Any exiting environment variable <code>&quot;OCAMLRUNPARAM&quot;</code> will be kept, however.</p><p>Exit Codes</p><p>The exit code used to leave this process depends on <code>conformant_subprocess_exitcodes</code>.</p><p>When <code>conformant_subprocess_exitcodes = true</code> or <code>conformant_subprocess_exitcodes</code> is not specified, the exit code will be the same as the spawned process exit code if and only if the exit code belongs to one of <a href="Forward_progress/Exit_code/index.html"><code>Forward_progress.Exit_code</code></a>; if the spawned exit code does not belong then the exit code will be <a href="Forward_progress/Exit_code/index.html#type-t.Exit_transient_failure"><code>Forward_progress.Exit_code.t.Exit_transient_failure</code></a>.</p><p>When <code>conformant_subprocess_exitcodes = false</code> the exit code will always be <a href="Forward_progress/Exit_code/index.html#type-t.Exit_transient_failure"><code>Forward_progress.Exit_code.t.Exit_transient_failure</code></a> if the spawned process ends in error.</p></div></div><h5 id="uninstallation"><a href="#uninstallation" class="anchor"></a>Uninstallation</h5><div class="odoc-spec"><div class="spec value anchored" id="val-uninstall_directory_onerror_exit"><a href="#val-uninstall_directory_onerror_exit" class="anchor"></a><code><span><span class="keyword">val</span> uninstall_directory_onerror_exit : 
  <span>id:string <span class="arrow">&#45;&gt;</span></span>
  <span>dir:<span class="xref-unresolved">Fpath</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span>wait_seconds_if_stuck:float <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>uninstall_directory ~id ~dir ~wait_seconds_if_stuck</code> removes the directory <code>dir</code> and, if any process is using the files in <code>dir</code>, will give the <code>wait_seconds_if_stuck</code> seconds to stop using the program. If the directory cannot be removed then prints an error on the fatal logger <code>fl ~id</code> and exists with a transient error code.</p><p>For Windows machines a file cannot be removed if it is in use. For most *nix machines the file can be removed since the inode lives on. Consequently only on Windows machines will trigger the logic to check if a process is using a file or directory. This behavior may change in the future.</p></div></div><h5 id="logging"><a href="#logging" class="anchor"></a>Logging</h5><p>Logging follows the Cmdliner standards.</p><p>All dkml_install generated executables can be supplied with the following options:</p><pre>      --color=WHEN (absent=auto)
          Colorize the output. WHEN must be one of `auto', `always' or
          `never'.

      -q, --quiet
          Be quiet. Takes over -v and --verbosity.

      -v, --verbose
          Increase verbosity. Repeatable, but more than twice does not bring
          more.

      --verbosity=LEVEL (absent=warning)
          Be more or less verbose. LEVEL must be one of `quiet', `error',
          `warning', `info' or `debug'. Takes over -v.</pre><p>You can use <a href="Log_config/index.html"><code>Log_config</code></a> to pass the color and verbosity options into your own bytecode executables.</p><p>Start by initializing the logger in your own executables with the following <code>setup_log_t</code> Cmdliner Term:</p><pre class="language-ocaml"><code>let setup_log style_renderer level =
  Fmt_tty.setup_std_outputs ?style_renderer ();
  Logs.set_level level;
  Logs.set_reporter (Logs_fmt.reporter ());
  Dkml_install_api.Log_config.create ?log_config_style_renderer:style_renderer
    ?log_config_level:level ()

let setup_log_t =
  Term.(const setup_log $ Fmt_cli.style_renderer () $ Logs_cli.level ())</code></pre><p>Finally, with a <a href="Log_config/index.html#type-t"><code>Log_config.t</code></a> you can use <a href="Log_config/index.html#val-to_args"><code>Log_config.to_args</code></a> to pass the correct command line options into your own executables. For components that are configured to spawn bytecode programs you can locate the <a href="Log_config/index.html#type-t"><code>Log_config.t</code></a> in the <a href="Context/index.html#type-t.log_config"><code>Dkml_install_api.Context.t.log_config</code></a> (<code>ctx.Dkml_install_api.Context.log_config</code>) context field. That could look like:</p><pre class="language-ocaml"><code>let execute ctx =
  let ocamlrun =
    ctx.Context.path_eval &quot;%{staging-ocamlrun:share-abi}/bin/ocamlrun&quot;
  in
  log_spawn_onerror_exit
    (* Always use your own unique id; create it with PowerShell on Windows:
          [guid]::NewGuid().Guid.Substring(0,8)
       or on macOS/Unix:
          uuidgen | tr A-Z a-z | cut -c1-8
     *)
    ~id:&quot;9b7e32e0&quot;
    Cmd.(
      v (Fpath.to_string
          (ctx.Context.path_eval &quot;%{staging-ocamlrun:share-abi}/bin/ocamlrun&quot;))
      % Fpath.to_string
          (ctx.Context.path_eval &quot;%{_:share}%/generic/your_bytecode.bc&quot;)
      (* Pass --verbosity and --color to your bytecode *)
      %% of_list (Array.to_list (Log_config.to_args ctx.Context.log_config)))

let () =
  let reg = Component_registry.get () in
  Component_registry.add_component reg
    (module struct
      include Default_component_config

      let component_name = &quot;enduser-yourcomponent&quot;

      let install_depends_on = [ &quot;staging-ocamlrun&quot; ]

      let install_user_subcommand ~component_name:_ ~subcommand_name ~fl ~ctx_t =
        let doc = &quot;Install your component&quot; in
        Dkml_install_api.Forward_progress.Continue_progress (Cmdliner.Term.(const execute $ ctx_t, info subcommand_name ~doc), fl)
    end)</code></pre><p>Others can use the <a href="Log_config/index.html#type-t"><code>Log_config.t</code></a> return value from <code>setup_log</code> when calling <a href="Log_config/index.html#val-to_args"><code>Log_config.to_args</code></a>.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Log_config"><a href="#module-Log_config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Log_config/index.html">Log_config</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Log_config/index.html">Log_config</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Forward_progress"><a href="#module-Forward_progress" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Forward_progress/index.html">Forward_progress</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Forward_progress</code> provides common functions to handle graceful and informative exits from the nested chain of subprocesses typical in DKML Install API and many other applications.</p></div></div></div></body></html>